// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Pausable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "hardhat/console.sol";

contract OrangeAvatar is Ownable, ERC721Enumerable, ERC721Pausable {
  using Counters for Counters.Counter;
  using Strings for uint256;

  struct Category {
    string name;
  }

  address public minter;

  Counters.Counter private _categoryIds;

  mapping(uint256 => Category) public categoryInfo;
  mapping(string => uint256) public categoryIdByRarity;
  mapping(uint256 => uint256) public idToCategory;

  string private _baseTokenURI;

  /**
   * @dev Throws if called by any account other than the minter.
   */
  modifier onlyMinter() {
    require(minter == _msgSender(), "OrangeAvatar::only minter");
    _;
  }

  constructor(string memory baseTokenURI) ERC721("OrangeAvatar", "OVATAR") {
    _baseTokenURI = baseTokenURI;

    minter = _msgSender();

    _addCategoryInfo("SSR");
    _addCategoryInfo("SR");
    _addCategoryInfo("R");
    _addCategoryInfo("N");
    _addCategoryInfo("SOUVENIR");
  }

  function baseURI() external view returns (string memory) {
    return _baseURI();
  }

  function categoryName(uint256 tokenId) external view returns (string memory) {
    return categoryInfo[idToCategory[tokenId]].name;
  }

  /**
   * @dev See {IERC721Metadata-tokenURI}.
   */
  function tokenURI(uint256 tokenId)
    public
    view
    override
    returns (string memory)
  {
    require(
      _exists(tokenId),
      "ERC721Metadata: URI query for nonexistent token"
    );

    string memory baseURI = _baseURI();
    string memory tokenURI =
      string(abi.encodePacked(tokenId.toString(), ".json"));
    return
      bytes(baseURI).length > 0
        ? string(abi.encodePacked(baseURI, tokenURI))
        : tokenURI;
  }

  /**
   * @dev Creates a new token for `to`. Its token ID will be automatically
   * assigned (and available on the emitted {IERC721-Transfer} event), and the token
   * URI autogenerated based on the base URI passed at construction.
   *
   * See {ERC721-_mint}.
   *
   * Requirements:
   *
   * - the caller must have the `MINTER_ROLE`.
   */
  function mint(
    address to,
    uint256 tokenId,
    uint256 categoryId
  ) external onlyMinter {
    require(
      0 < categoryId && categoryId <= _categoryIds.current(),
      "OrangeAvatar::mint::invalid categoryId"
    );

    idToCategory[tokenId] = categoryId;

    _mint(to, tokenId);
  }

  function _baseURI() internal view override returns (string memory) {
    return _baseTokenURI;
  }

  function _beforeTokenTransfer(
    address from,
    address to,
    uint256 tokenId
  ) internal virtual override(ERC721Enumerable, ERC721Pausable) {
    super._beforeTokenTransfer(from, to, tokenId);
  }

  /**
   * @dev See {IERC165-supportsInterface}.
   */
  function supportsInterface(bytes4 interfaceId)
    public
    view
    virtual
    override(ERC721, ERC721Enumerable)
    returns (bool)
  {
    return super.supportsInterface(interfaceId);
  }

  function _addCategoryInfo(string memory name) internal {
    // id starts from 1
    _categoryIds.increment();
    uint256 newId = _categoryIds.current();
    categoryInfo[newId] = Category({name: name});
    categoryIdByRarity[name] = newId;
  }

  function setMinter(address newMinter) external {
    if (minter == _msgSender()) {
      minter = newMinter;
    }
  }

  /**
   * @dev function to set the base URI for all token IDs. It is
   * automatically added as a prefix to the value returned in {tokenURI},
   * or to the token ID if {tokenURI} is empty.
   */
  function setBaseURI(string memory newBaseURI) external onlyOwner {
    _baseTokenURI = newBaseURI;
  }
}
