// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Pausable.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "hardhat/console.sol";

contract OrangeAvatar is
  AccessControlEnumerable,
  ERC721Enumerable,
  ERC721Pausable
{
  using Counters for Counters.Counter;
  using Strings for uint256;

  struct Category {
    string rarity; // category URI, a super set of token's uri (it can be either uri or a path (if specify a base URI))
    uint256 timestamp;
  }

  bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
  bytes32 public constant GOVERNANCE_ROLE = keccak256("GOVERNANCE_ROLE");

  Counters.Counter private _tokenIds;
  Counters.Counter private _categoryIds;

  mapping(uint256 => Category) public categoryInfo;
  mapping(string => uint256) public categoryIdByRarity;
  mapping(uint256 => uint256) public idToCategory;

  string private _baseTokenURI;

  /// @dev only the one having a GOVERNANCE_ROLE can continue an execution
  modifier onlyGovernance() {
    require(
      hasRole(GOVERNANCE_ROLE, _msgSender()),
      "OrangeAvatar::onlyGovernance::only GOVERNANCE role"
    );
    _;
  }

  /// @dev only the one having a MINTER_ROLE can continue an execution
  modifier onlyMinter() {
    require(
      hasRole(MINTER_ROLE, _msgSender()),
      "OrangeAvatar::onlyMinter::only MINTER role"
    );
    _;
  }

  constructor(string memory baseTokenURI) ERC721("OrangeAvatar", "OVATAR") {
    _baseTokenURI = baseTokenURI;

    _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
    _setupRole(MINTER_ROLE, _msgSender());
    _setupRole(GOVERNANCE_ROLE, _msgSender());

    _addCategoryInfo("SSR");
    _addCategoryInfo("SR");
    _addCategoryInfo("R");
    _addCategoryInfo("N");
  }

  function baseURI() external view returns (string memory) {
    return _baseURI();
  }

  function getRarity(uint256 tokenId) external view returns (string memory) {
    return categoryInfo[idToCategory[tokenId]].rarity;
  }

  /**
   * @dev See {IERC721Metadata-tokenURI}.
   */
  function tokenURI(uint256 tokenId)
    public
    view
    override
    returns (string memory)
  {
    require(
      _exists(tokenId),
      "ERC721Metadata: URI query for nonexistent token"
    );

    string memory baseURI = _baseURI();
    string memory tokenURI = string(
      abi.encodePacked(tokenId.toString(), ".json")
    );
    return
      bytes(baseURI).length > 0
        ? string(abi.encodePacked(baseURI, tokenURI))
        : tokenURI;
  }

  /**
   * @dev Creates a new token for `to`. Its token ID will be automatically
   * assigned (and available on the emitted {IERC721-Transfer} event), and the token
   * URI autogenerated based on the base URI passed at construction.
   *
   * See {ERC721-_mint}.
   *
   * Requirements:
   *
   * - the caller must have the `MINTER_ROLE`.
   */
  function mint(address to, uint256 categoryId)
    external
    onlyMinter
    returns (uint256 id)
  {
    require(
      _categoryIds.current() >= categoryId,
      "OrangeAvatar::mint::invalid categoryId"
    );

    uint256 newId = _tokenIds.current();
    _tokenIds.increment();
    idToCategory[newId] = categoryId;

    _mint(to, newId);
    return newId;
  }

  function _baseURI() internal view override returns (string memory) {
    return _baseTokenURI;
  }

  function _beforeTokenTransfer(
    address from,
    address to,
    uint256 tokenId
  ) internal virtual override(ERC721Enumerable, ERC721Pausable) {
    super._beforeTokenTransfer(from, to, tokenId);
  }

  /**
   * @dev See {IERC165-supportsInterface}.
   */
  function supportsInterface(bytes4 interfaceId)
    public
    view
    virtual
    override(AccessControlEnumerable, ERC721, ERC721Enumerable)
    returns (bool)
  {
    return super.supportsInterface(interfaceId);
  }

  /// @notice add category (group of tokens)
  /// @param _rarity a name of a category
  function _addCategoryInfo(string memory _rarity) internal {
    // id starts from 1
    _categoryIds.increment();
    uint256 newId = _categoryIds.current();
    categoryInfo[newId] = Category({
      rarity: _rarity,
      timestamp: block.timestamp
    });
    categoryIdByRarity[_rarity] = newId;
  }

  /**
   * @dev function to set the base URI for all token IDs. It is
   * automatically added as a prefix to the value returned in {tokenURI},
   * or to the token ID if {tokenURI} is empty.
   */
  function setBaseURI(string memory newBaseURI) external onlyGovernance {
    _baseTokenURI = newBaseURI;
  }
}
